# -*- coding: utf-8 -*-
"""Zip_vs_County_Adoption_Rates.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SyrlGEryMW4LEjGUvOuxbZeHJFPXTUWa
"""

import pandas as pd

county_data_2023 = pd.read_csv("/content/ZipCodeToCounty.csv")  # Dataset 1
vehicle_data = pd.read_csv("/content/ElectricVehicles2023.csv") # Dataset 2
vehicles_by_zip = vehicle_data.groupby("ZIP")["Number of Vehicles"].sum().reset_index()

merged = pd.merge(county_data_2023, vehicles_by_zip, on="ZIP", how="outer", indicator=True)

# Count the number of unmatched rows
num_unmatched = (merged["_merge"] != "both").sum()
print(f"Number of ZIPs that didn't match: {num_unmatched}")

merged["EVs per Capita"] = merged["Number of Vehicles"] / merged["ZIP Code Population"]
merged = merged[merged["County"].notna()]
merged

# Normalize both columns
merged["County"] = merged["County"].str.replace(" County", "", regex=False)

# Drop any already-merged versions of the columns
merged = merged.drop(columns=["Population", "ZEV Sales"], errors="ignore")

# Merge on the "County" column
county_data_2023 = county_data_2023.rename(columns={"COUNTY": "County"})

# Delete unecessary columns
merged.drop(columns=["USPS Default State for ZIP", "_merge"], inplace=True)
merged.head()

# Remove zip codes below a population threshold (100 residents)
merged = merged[merged["ZIP Code Population"] > 100]

# Compute county-level weighted average
county_weighted_avg = (
    merged.dropna(subset=["ZIP Code Population", "Number of Vehicles"])
          .groupby("County", group_keys=False)
          .apply(lambda g: g["Number of Vehicles"].sum() / g["ZIP Code Population"].sum())
          .reset_index(name="County_EVs_per_Capita")
)

merged = merged.drop(columns=["County_EVs_per_Capita"], errors="ignore")
merged = merged.merge(county_weighted_avg, on="County", how="left")

# Compare using correct column name
merged["Below Average"] = merged["EVs per Capita"] < 0.8 * merged["County_EVs_per_Capita"]

print("County-Level EVs per Capita")
print(county_weighted_avg.sort_values("County_EVs_per_Capita", ascending=False).head(10))

# Disparity metrics

merged["Adoption Gap"] = merged["County_EVs_per_Capita"] - merged["EVs per Capita"]
merged["Adoption Ratio"] = merged["EVs per Capita"] / merged["County_EVs_per_Capita"]

print("ZIPs with Largest Absolute Gaps")
print(
    merged.sort_values("Adoption Gap", ascending=False)[
        ["ZIP", "County", "EVs per Capita", "County_EVs_per_Capita", "Adoption Gap", "ZIP Code Population"]
    ].head(10)
)

print("ZIPs with Largest Relative Gaps (Lowest Ratios)")
print(
    merged[merged["County_EVs_per_Capita"] > 0]  # Avoid divide-by-zero
    .sort_values("Adoption Ratio")[
        ["ZIP", "County", "EVs per Capita", "County_EVs_per_Capita", "Adoption Ratio", "ZIP Code Population"]
    ].head(10)
)

import matplotlib.pyplot as plt

# Calculate standard deviation of EV adoption within each county
county_std = (
    merged.groupby("County")["EVs per Capita"]
    .std()
    .sort_values(ascending=False)
    .dropna()
)

# View top counties by internal disparity
print("Top 10 Counties by Standard Deviation in EV Adoption Across ZIPs")
print(county_std.head(10))

# Plot the top 10
top_std = county_std.head(10)

plt.figure(figsize=(10, 6))
top_std.plot(kind="bar", color="skyblue")
plt.title("Top 10 Counties by Standard Deviation of EV Adoption (ZIP Level)")
plt.ylabel("Standard Deviation of EVs per Capita")
plt.xlabel("County")
plt.xticks(rotation=45, ha="right")
plt.grid(axis="y")
plt.tight_layout()
plt.show()

# Z-score Outlier Detection (Per County)
# Which ZIPs are statistical outliers within their county?

merged["County_Mean"] = merged.groupby("County")["EVs per Capita"].transform("mean")
merged["County_Std"] = merged.groupby("County")["EVs per Capita"].transform("std")
merged["Z_Score"] = (merged["EVs per Capita"] - merged["County_Mean"]) / merged["County_Std"]

# Flag ZIPs with Z-score > 2 or < -2
outliers = merged[merged["Z_Score"].abs() > 2]
print(outliers[["ZIP", "County", "EVs per Capita", "Z_Score"]])

# Underperformers: More than 2 std dev below county average
underperformers = merged[merged["Z_Score"] < -2]

# Overperformers: More than 2 std dev above county average
overperformers = merged[merged["Z_Score"] > 2]

# Only look at top 10 underperformers and overperformers
top_under = underperformers.sort_values("Z_Score").head(10)
top_over = overperformers.sort_values("Z_Score", ascending=False).head(10)
top_under["Category"] = "Underperformer"
top_over["Category"] = "Overperformer"
top_outliers_combined = pd.concat([top_under, top_over])
print(top_outliers_combined)

import matplotlib.pyplot as plt

# Sort so underperformers appear at bottom
combined = top_outliers_combined.sort_values("Z_Score")

plt.figure(figsize=(10, 6))
bars = plt.barh(combined["ZIP"].astype(str), combined["Z_Score"], color=combined["Category"].map({"Underperformer": "salmon", "Overperformer": "seagreen"}))
plt.axvline(0, color="black", linestyle="--")
plt.title("Top EV Adoption Outliers by ZIP (Z-Score Relative to County)")
plt.xlabel("Z-Score")
plt.ylabel("ZIP Code")
plt.grid(True, axis="x")
plt.tight_layout()
plt.show()

import plotly.express as px

# Filter to only rows with complete data
filtered = merged.dropna(subset=["County_EVs_per_Capita", "EVs per Capita", "ZIP"])

# Create interactive scatter plot with hover info
fig = px.scatter(
    filtered,
    x="County_EVs_per_Capita",
    y="EVs per Capita",
    color="County",
    hover_name="ZIP",
    hover_data={"County": True, "ZIP Code Population": True},
    labels={
        "County_EVs_per_Capita": "County EVs per Capita",
        "EVs per Capita": "ZIP EVs per Capita"
    },
    title="ZIP vs County EV Adoption Rates (Interactive)"
)

# Add diagonal reference line (y = x)
fig.add_shape(
    type="line",
    x0=0, y0=0,
    x1=filtered["County_EVs_per_Capita"].max(),
    y1=filtered["County_EVs_per_Capita"].max(),
    line=dict(color="red", dash="dash")
)

fig.update_layout(height=800, width=800)
fig.show()